plugins {
    id "org.jetbrains.intellij" version "0.4.10"
}

version = file('version.txt').text.trim()

task validateDic(type: Exec) {
    commandLine './tools/validate-dic'
}

task runJFlex(type: Exec) {
    commandLine './tools/run-jflex'
}

task cleanJFlex(type: Exec) {
    commandLine './tools/run-jflex', 'clean'
}

String findIntelliJLibCacheDir() {
    String baseDir =
      "${gradle.gradleUserHomeDir}/caches/modules-2/files-2.1/" +
        "com.jetbrains.intellij.idea/ideaIC/${intellijVersionNumber}"
    // Relative to the dir above, get the matching "./*/ideaIC-$version/lib" dir
    for (File d : file(baseDir).listFiles({ it.directory } as FileFilter)) {
        File[] ds = d.listFiles({ it.directory && it.name == "ideaIC-${intellijVersionNumber}" } as FileFilter)
        if (ds.length == 0) continue
        File[] libDirs = ds[0].listFiles({ it.directory && it.name == "lib" } as FileFilter)
        if (libDirs.length == 0) continue
        String res = libDirs[0].canonicalPath
        println("Found intellij lib cache dir: ${res}")
        return res
    }
    throw new RuntimeException("Failed to find intellij lib cache dir!")
}

ext {
    javaVersion = '1.8'
    scalaVersion = '2.12.4'
    scalaBinaryVersion = '2.12'

    // Ensure that we've tested HaskForce with the given major IntelliJ
    // version before changing these values.
    // See https://github.com/carymrobbins/intellij-haskforce/issues/407
    intellijVersionNumber = '2019.3.1'
    intellijVersionUntil  = '2019.3.*'

    intellijLibCacheDir = findIntelliJLibCacheDir()
}

allprojects {

    apply plugin: 'java'
    apply plugin: 'scala'
    apply plugin: 'org.jetbrains.intellij'

    intellij {
        version = intellijVersionNumber
        pluginName = 'HaskForce'
        plugins = ['java', 'yaml']
    }

    patchPluginXml {
    }

    repositories {
        mavenCentral()
    }

    configurations {
        provided
        compile.extendsFrom provided
    }

    dependencies {

        // Scala support
        compileOnly "org.scala-lang:scala-compiler:${scalaVersion}"
        compile "org.scala-lang:scala-reflect:${scalaVersion}"
        compile "org.scala-lang:scala-library:${scalaVersion}"

        compile "io.estatico:newtype_${scalaBinaryVersion}:0.1.0"
        compile "org.scalaz:scalaz-core_${scalaBinaryVersion}:7.2.17"
        compile "org.yaml:snakeyaml:1.16"

        compile files("${intellijLibCacheDir}/platform-api.jar")
        compile files("${intellijLibCacheDir}/platform-ide-util-io.jar")
        compile files("${intellijLibCacheDir}/jdom.jar")
        compile files("${intellijLibCacheDir}/annotations.jar")

        // Compile-time-only deps.
        compileOnly "com.google.code.findbugs:findbugs:3.0.1"
        compileOnly "com.google.guava:guava:21.0"
    }

    // NOTE: We have Scala and Java sources that depend on each other, and the java.srcDirs
    // will try to be compiled first, so instead we're just setting the scala.srcDirs.
    sourceSets {
        main {
            scala.srcDirs 'src', 'gen'
            resources.srcDirs 'resources'
        }
        test {
            scala.srcDirs 'tests'
            resources.srcDirs 'tests'
        }
    }
}

assemble.dependsOn(validateDic, runJFlex)

project(':jps-plugin') {
    dependencies {
        compile project(':jps-shared')
    }
}

// Override the intellij type to be JPS for jps projects.
// TODO: This can be cleaned up
[':jps-plugin', ':jps-shared'].each {
    project(it) {
        intellij {
            type = 'JPS'
        }
    }
}

// Proof-of-concept demonstration that we have access to the jar files.
project(':jps-plugin').configurations.compile.each { dep ->
    // Ensure that we have a valid jar reference.
    if (dep.file) {
        println("dep: ${dep.name} ; ${dep}")
    } else {
        throw new RuntimeException("Invalid dependency: ${dep}")
    }
}

dependencies {
    compile project(':macros')
    compile project(':jps-shared')
    compile project(':jps-plugin')
}

static def getGitRev() {
    def proc = "git rev-parse --short HEAD".execute()
    proc.waitFor()
    return proc.text.trim()
}

static def isGitDirty() {
    return "git diff-index --quiet HEAD".execute().waitFor() != 0
}

def getPluginVersion() {
    if (version.endsWith('SNAPSHOT')) {
        if (isGitDirty()) {
            return "$version-${getGitRev()}-dirty"
        } else {
            return "$version-${getGitRev()}"
        }
    } else {
        return version
    }
}

clean.dependsOn cleanJFlex

compileJava.dependsOn runJFlex

// Fixes "unmappable character for encoding ASCII" when compiling files
// containing unicode characters in strings via IntelliJ gradle tasks.
compileJava.options.encoding = "UTF-8"
compileTestJava.options.encoding = "UTF-8"
compileScala.options.encoding = "UTF-8"
compileTestScala.options.encoding = "UTF-8"

patchPluginXml {
    version = getPluginVersion()
    sinceBuild = intellijVersionNumber
    untilBuild = intellijVersionUntil
}

// Allow re-running tests without forcing a recompile.
test.outputs.upToDateWhen { false }

buildPlugin {
    archiveName = "haskforce-${patchPluginXml.version}.zip"
}

test {
    if ("1" == System.getenv("OVERWRITE_FIXTURES")) {
        systemProperties.put("idea.tests.overwrite.data", "true")
    }
}
